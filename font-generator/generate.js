const { createCanvas, registerFont } = require('canvas');
const fs = require('fs');
const path = require('path');

// Font sizes to generate: width x height
const FONT_SIZES = [
  { width: 12, height: 16 },
  { width: 16, height: 24 },
  { width: 24, height: 36 },
  { width: 32, height: 48 },
  { width: 48, height: 54 }
];

// Font weight (normal, bold, etc.)
const FONT_WEIGHT = '600';

// ASCII character range (32-127)
const CHAR_START = 32;
const CHAR_END = 127;
const CHAR_COUNT = CHAR_END - CHAR_START + 1;

function generateBitmapFont(fontPath, fontSize) {
  const { width, height } = fontSize;

  // Register the font
  registerFont(fontPath, { family: 'CustomFont' });

  // Use 2x scaling for better anti-aliasing control
  const scale = 2;
  const canvas = createCanvas(width * scale, height * scale);
  const ctx = canvas.getContext('2d');

  // Set font properties at scaled size
  ctx.font = `${FONT_WEIGHT} ${height * scale}px CustomFont`;
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'alphabetic';

  const bitmapData = [];

  for (let charCode = CHAR_START; charCode <= CHAR_END; charCode++) {
    // Clear canvas
    ctx.clearRect(0, 0, width * scale, height * scale);

    // Draw character at scaled size with alphabetic baseline
    const char = String.fromCharCode(charCode);
    ctx.fillText(char, (width * scale) / 2, (height * scale) * 0.8);

    // Get scaled image data
    const scaledImageData = ctx.getImageData(0, 0, width * scale, height * scale);
    
    // Downscale by averaging 2x2 pixel blocks
    const downsampledPixels = downsampleImage(scaledImageData.data, width * scale, height * scale, width, height);

    // Convert to bitmap (row by row, 8 pixels per byte)
    const charBitmap = [];
    const bytesPerRow = Math.ceil(width / 8);

    for (let y = 0; y < height; y++) {
      for (let byteX = 0; byteX < bytesPerRow; byteX++) {
        let byte = 0;

        for (let bit = 0; bit < 8; bit++) {
          const x = byteX * 8 + bit;
          if (x < width) {
            const pixelIndex = y * width + x;
            const alpha = downsampledPixels[pixelIndex];
            
            // Use size-adaptive threshold to preserve thin lines in smaller fonts
            const threshold = getAdaptiveThreshold(width, height);
            if (alpha > threshold) {
              byte |= (1 << (7 - bit));
            }
          }
        }

        charBitmap.push(byte);
      }
    }

    bitmapData.push(charBitmap);
  }

  return bitmapData;
}

function downsampleImage(pixels, srcWidth, srcHeight, dstWidth, dstHeight) {
  const scaleX = srcWidth / dstWidth;
  const scaleY = srcHeight / dstHeight;
  const result = new Array(dstWidth * dstHeight);

  for (let dstY = 0; dstY < dstHeight; dstY++) {
    for (let dstX = 0; dstX < dstWidth; dstX++) {
      let alphaSum = 0;
      let sampleCount = 0;

      // Sample from the corresponding area in source image
      const srcStartX = Math.floor(dstX * scaleX);
      const srcEndX = Math.min(Math.ceil((dstX + 1) * scaleX), srcWidth);
      const srcStartY = Math.floor(dstY * scaleY);
      const srcEndY = Math.min(Math.ceil((dstY + 1) * scaleY), srcHeight);

      for (let srcY = srcStartY; srcY < srcEndY; srcY++) {
        for (let srcX = srcStartX; srcX < srcEndX; srcX++) {
          const srcIndex = (srcY * srcWidth + srcX) * 4 + 3; // Alpha channel
          alphaSum += pixels[srcIndex];
          sampleCount++;
        }
      }

      result[dstY * dstWidth + dstX] = sampleCount > 0 ? alphaSum / sampleCount : 0;
    }
  }

  return result;
}

function getAdaptiveThreshold(width, height) {
  // Use lower threshold for smaller fonts to preserve thin lines
  // Use higher threshold for larger fonts for cleaner results
  const pixelArea = width * height;
  
  if (pixelArea <= 192) {        // 12x16 = 192
    return 128;
  } else if (pixelArea <= 384) { // 16x24 = 384
    return 160;
  } else {                       // 24x36+ = 864+
    return 192;
  }
}

function generateCFile(fontName, fontSize, bitmapData) {
  const { width, height } = fontSize;
  const bytesPerChar = Math.ceil(width / 8) * height;
  const totalBytes = bytesPerChar * CHAR_COUNT;

  let cCode = `#include <stdint.h>\n\n`;
  cCode += `// ${fontName}_${width}x${height}.c\n`;
  cCode += `// Font type    : Full (${CHAR_COUNT} characters)\n`;
  cCode += `// Font size    : ${width}x${height} pixels\n`;
  cCode += `// Generated by ChipNomad bitmap font generator (2x oversampling, adaptive threshold)\n\n`;
  cCode += `uint8_t font${width}x${height}[${totalBytes}] = {\n`;

  for (let charIndex = 0; charIndex < CHAR_COUNT; charIndex++) {
    const charCode = CHAR_START + charIndex;
    const char = String.fromCharCode(charCode);
    const charName = getCharName(char);

    const charData = bitmapData[charIndex];
    const hexBytes = charData.map(byte => `0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);

    cCode += hexBytes.join(',') + `,  // ${charName}\n`;
  }

  cCode += `};\n`;

  return cCode;
}

function getCharName(char) {
  const charCode = char.charCodeAt(0);

  if (charCode === 32) return '<space>';
  if (charCode === 92) return '<backslash>';
  if (charCode >= 33 && charCode <= 126) return char;

  return `<${charCode}>`;
}

function main() {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.log('Usage: node generate.js <font-file.ttf> [output-dir]');
    console.log('');
    console.log('Generates bitmap fonts in the following sizes:');
    FONT_SIZES.forEach(size => {
      console.log(`  ${size.width}x${size.height} pixels`);
    });
    process.exit(1);
  }

  const fontPath = args[0];
  const outputDir = args[1] || './output';

  if (!fs.existsSync(fontPath)) {
    console.error(`Font file not found: ${fontPath}`);
    process.exit(1);
  }

  // Create output directory
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const fontName = path.basename(fontPath, path.extname(fontPath));

  console.log(`Generating bitmap fonts from: ${fontPath}`);
  console.log(`Output directory: ${outputDir}`);
  console.log('');

  FONT_SIZES.forEach(fontSize => {
    console.log(`Generating ${fontSize.width}x${fontSize.height}...`);

    try {
      const bitmapData = generateBitmapFont(fontPath, fontSize);
      const cCode = generateCFile(fontName, fontSize, bitmapData);

      const outputFile = path.join(outputDir, `font_${fontSize.width}x${fontSize.height}.c`);
      fs.writeFileSync(outputFile, cCode);

      console.log(`  Generated: ${outputFile}`);
    } catch (error) {
      console.error(`  Error generating ${fontSize.width}x${fontSize.height}: ${error.message}`);
    }
  });

  console.log('\\nDone!');
}

if (require.main === module) {
  main();
}